# file: core.py
# content: core
# created: 2025 Mai 28 Wednesday
# author: roch schanen

class logic_port():

    # signal count for signal names
    sn = 0

    # constructor
    def __init__(self):
        # record signal name
        self.sg = f"W{self.sn}"
        # increment global signal count
        logic_port.sn += 1
        # declare port state
        self.ps = None
        # done
        return

    def get(self, ss = None):
        # return full port state
        if ss is None: return self.ps
        # return subset of port state
        return "".join([self.ps[i] for i in ss])

    def size(self):
        return len(self.ps)

    def set(self, ns):
        self.utd = (self.ps == ns)
        self.ps = ns
        return

    def export(self):
        # check for update
        if self.utd: return f""
        # set flag
        self.utd = True
        # multiple bits case
        if self.size() > 1:
            return f"b{self.ps[::-1]} {self.sg}{SPC}"
        # single bit case
        return f"{self.ps}{self.sg}{SPC}"

class logic_port_output(logic_port):

    gn = "Q"

    # constructor
    def __init__(self, bw = 1):
        # call logic_port constructor
        logic_port.__init__(self)
        # set port state
        self.set('U'*bw)
        # done
        return

class logic_port_input(logic_port):

    gn = "P"

    # constructor
    def __init__(self, lpo, ss = None):
        # call logic_port constructor
        logic_port.__init__(self)
        # get target port size
        n = lpo.size()
        # build port subset list
        self.ss = list(range(n)) if ss else ss
        # record target
        self.lpo = lpo
        # init state
        self.update()
        # done
        return

    def update(self):
        # get output port state
        ns = self.lpo.get(self.ss)
        # (to do: insert wire delay here...)
        # single bit case
        if len(ns) == 1:
            self.rising  = (self.ps, ns) == ('0','1')
            self.falling = (self.ps, ns) == ('1','0')
        # update input port state
        self.set(ns)
        # done
        return

class logic_device():

    gn = "D"

    def __init__(self):
        # declare device contents
        self.i = {} # inputs
        self.o = {} # outputs
        self.d = {} # devices
        # call user init
        self.start()
        #done
        return

    def export(self):
        expstr = ""
        for i in self.i.values(): expstr += i.export()
        for o in self.o.values(): expstr += o.export()
        for d in self.d.values(): expstr += d.export()
        return expstr

    # this is a template to be over-written
    def start(self):
        pass        

    # display this device (possibly sub-devices)
    def display(self):
        pass

    def update_input_ports(self):
        # update all inputs for this device
        for i in self.i.values(): i.update()
        # update all inputs for the sub devices
        for d in self.d.values(): d.update_input_ports()
        # done
        return

    # this is a template to be over-written
    def update_output_ports(self, timeStamp):
        
        # update all sub-devices outputs
        for d in self.d.values():
            self.d.update_outputs(timeStamp)

        """ compute this device output ports from this
        device inputs, sub-devices outputs, timestamp,
        and other internal structure.
        """

        # done
        return

    # add an element (device, port, ...)
    # use defined name or generic
    def add(self):
        # check for duplicates
        # add name to 
        pass

    add names















# SYMBOLS
# EOL, SPC, NUL = "\n", " ", ""   

# class VCDfile():

#     def __init__(self, sh, fp = "./export.vcd"):
#         # create file handle if path is given
#         fh = self.create(fp) if fp else None
#         # record conficguration
#         self.config = sh, fh, 0
#         # done
#         return

#     def create(self, fp):
#         # load configuration
#         sh, fh, N = self.config
#         # close handle if active
#         if fh: fh.close()
#         # create file (new file)
#         fh = open(fp, 'w')
#         # make header
#         fh.write(f"$version Generated by simsys.py $end{EOL}")
#         fh.write(f"$date {sh.date} $end{EOL}")
#         fh.write(f"$timescale 1ns $end{EOL}")
#         # make modules and signals
#         fh.write(f"$scope module SYSTEM $end{EOL}")
#         # recursively build the list of devices in the system
#         for d in sh.devicelist.values(): d.makeModule()     ### !!!
#         fh.write(f"$upscope $end{EOL}")
#         # close header
#         fh.write(f"$enddefinitions $end{EOL}")
#         # done
#         return fh

#     def export(self):
#         # load configuration
#         sh, fh, N = self.config
#         # recursively build the export string
#         expstr = ""
#         for d in sh.devicelist.values(): expstr += d.export()
#         # check for empty string
#         if expstr is NUL: return
#         # export the string
#         fh.write(f"#{sh.time:04}")
#         fh.write(f"{SPC}{expstr}{EOL}")
#         # done
#         return

#     def close(self):
#         # export current state
#         self.export()
#         # close file
#         fh.close()
#         # save configuration
#         self.config = sh, fh, N
#         return




