#!/usr/bin/python3
# file: core.py
# content: system simulator core
# created: 2020 November 14 Saturday
# modified:
# modification:
# author: roch schanen
# comment: core classes

from time import strftime 
from sys import exit

# CONSTANTS ##########################################################

SEP = " "    # SIGNAL SEPARATOR
EOL = "\n"   # END-OF-LINE CODE

# SIGNAL COUNTER #####################################################

# the signal counter is used to define the wires name. the names are
# given in the format 'W%n' where 'n' is an index. The value of n is
# determined by the counter 'N' which is incremented every time a new
# wire is added.

N = 0

# SYSTEM #############################################################

# the system class collects devices, runs the engine and exports data

class system():

    def __init__(self, name):
        date = strftime("%A, %d %b %Y at %H:%M:%S")
        print(f"create system {name}\n{date}")
        self.devicelist = {}
        self.name = name
        self.date = date
        self.time = 0
        # done
        return

    # find the next index of a generic name
    def getName(self, generic):
        n, k = 0, f"{generic}0"
        while k in self.devicelist.keys():
            n += 1
            k = f"{generic}{n}"
        # found name
        return k

    # display all devices current status
    def displayDevices(self):
        print(f"System state at {self.time}ns")
        for d in self.devicelist.values(): d.display()            
        return

    # create VCD file and make file header. 
    def openFile(self, pathName = "./output_dev.vcd"):
        # create file
        fh = open(pathName, 'w')
        # make header
        fh.write(f"$version Generated by simsys.py $end{EOL}")
        fh.write(f"$date {self.date} $end{EOL}")
        fh.write(f"$timescale 1ns $end{EOL}")
        # make modules and signals
        fh.write(f"$scope module SYSTEM $end{EOL}")
        for d in self.devicelist.values(): d.makeModule(fh, 0)
        fh.write(f"$upscope $end{EOL}")
        # close header
        fh.write(f"$enddefinitions $end{EOL}")
        # done
        self.pathName = pathName
        self.fh = fh
        return

    # close VCD file
    def closeFile(self):
        self.fh.close()
        return

    # generate one step in the simulation
    # the step resolution is 1ns for now
    # this should be made a free parameter
    def runStep(self):
        # export new state
        exportResult = ""
        for device in self.devicelist.values():
            exportResult += device.export()
        # export
        if exportResult:
            self.fh.write(f"#{self.time:04}")
            self.fh.write(f"{SEP}{exportResult}{EOL}")
        # increase time by one interval (1ns)
        self.time += 1
        # update device outputs
        for device in self.devicelist.values():
            device.updateOutputPorts(self.time)
        # update device inputs
        for device in self.devicelist.values():
            device.updateInputPorts()        
        # done
        return

    # generate steps until "time" value is reached
    def runUntil(self, time):
        while self.time < time:
            self.runStep()
        return

    # add a device to the system
    # you find the devices in "library.py"
    def add(self, device):
        # get device given name
        name = device.name
        # check for duplicate
        if name in self.devicelist.keys():
            print(f"system.create({name}): duplicated name.")
            print(f"  name {name} already used.")
            print(f"  exiting...")
            exit()
        # make generic name
        if name == None:
            name = self.getName(device.genericName)
            # record new name
            device.name = name
        # register new device
        self.devicelist[name] = device
        # done
        return self.devicelist[name]

# PORT ###############################################################

# portCommon is the parent class for outPort and inPort

class portCommon():

    # all signals in the VCD file have name format "W%n" where n is
    # incremented every time a new signal is defined. the name
    # corresponding can be found in the VCD header.
    def addSignal(self):
        global N
        self.signal = f"W{N}"
        N += 1
        return self.signal

    # get a port state or a subset of a port state. subset is a list
    # of indices that defines which wire within the port is to be
    # selected. A port state is define by a string of bits. each bit
    # can have the values: '0', '1' or 'U' (more states in the futur).
    # The right most charater has the highest index value. The left
    # most character has index 0. for example, bit[3] of state "0001"
    # has the value '1'. all the other bits have the value '0'.
    def get(self, subset = None):
        # return port state as is
        if not subset:
            return self.state
        # return a subset
        value = ""
        for i in subset:
            value += self.state[i]
        return value

    # return the port size: the number of bits
    def size(self):
        return len(self.state)

    # export port value to VCD file (respecting the VCD format)
    def export(self):
        if self.signal:
            # no change
            if self.uptodate: return ""
            # set flag
            self.uptodate = True
            # bit string export
            if self.size() > 1:
                return f"b{self.state[::-1]} {self.signal}{SEP}"
            # single bit export
            return f"{self.state}{self.signal}{SEP}"
        # no signal
        return ""

# OUTPUT PORT ########################################################

class outPort(portCommon):

    def __init__(self, bits = 1, name = None):
        # initialise to undefined value 'U'
        self.state = 'U'*bits
        # register port name
        self.name = name
        # force update at origin
        self.uptodate = False
        # export signal
        self.signal = None
        return

    # 'set' asserts a newvalue of the port. The method detects if the
    # asserted value is different from the previous one and sets the
    # 'uptodate' flag accordingly. 'uptodate' is true if no change.
    def set(self, newvalue):
        # check type is string 
        if not isinstance(newvalue, str):
            print(f"port.set: value must be of string type.")
            print(f"  exiting...")
            exit()
        # check size
        if not len(newvalue) == self.size():
            print(f"port.set: value size mismatch:")
            print(f'  port.name = {self.name}')
            print(f"  value size is {len(newvalue)}.")
            print(f"  expected size is {self.size()}.")
            print(f"  exiting...")
            exit()
        # set flag
        self.uptodate = (self.state == newvalue)
        # update value
        self.state = newvalue
        # done
        return

# INPUT PORTS ########################################################
# an input port should always be linked to an output port. 'update'
# sets the new value of the input port from the output port. the
# rising' and 'falling' edge events are automatically detected. the
# 'uptodate' flag is also set accordingly.

class inPort(portCommon):

    def __init__(self, port, name = None, subset = None):
        # link inport to outport
        self.p = port
        # select subset
        self.w = subset
        if not subset:
            self.w = list(range(self.p.size()))
        # register port name
        self.name = name
        # initial state
        self.state = port.get(self.w)
        # force update at origin
        self.uptodate = False
        # export signal
        self.signal = None
        # clear edge events        
        self.rising  = False
        self.falling = False
        return

    def update(self):
        # get state from outport
        newvalue = self.p.get(self.w)
        # update flag
        self.uptodate = (self.state == newvalue)
        # update value
        if len(newvalue) > 1:
            self.state = newvalue
            return
        # single bit case        
        self.rising  = False
        self.falling = False
        # detect rising edge
        if (self.state, newvalue) == ('0','1'):
            self.rising = True                 
        # detect falling edge
        if (self.state, newvalue) == ('1','0'):
            self.falling = True
        # update state
        self.state = newvalue                 
        return

# DEVICE #############################################################
# the 'Device' class is a template class. 'writeVar' is used to format
# the header of the VCD file. 'makeModule' write this device header
# for the VCD file. 

class Device():

    genericName = "dev"

    def __init__(self, name):
        self.name = name
        self.inports  = []
        self.outports = []
        self.exports  = []
        return

    def writeVar(self,
            f,  # file
            t,  # tab level
            p): # port
        # write port signal
        if p.name:
            # register port in export list
            self.exports.append(p)
            # get size
            size = p.size()
            # get signal name
            label = f"{self.name}_{p.name}"
            if size > 1:
                label += f"[{size-1}:0]"
            # get signal identifier
            signal = p.addSignal()
            f.write(f"{t}\t$var")    # header
            f.write(f" wire {size}") # signal size
            f.write(f" {signal}")    # signal identifier
            f.write(f" {label}")     # signal name
            f.write(f" $end{EOL}")   # tail
        return

    def makeModule(self,
            f,  # file
            t): # tab level
        # get module name
        name = self.name
        # tab alignment
        tab  = '\t'*(t+1)
        # write header
        f.write(f"{tab}$scope module {name} $end{EOL}")
        # write variables (inputs)
        for p in self.inports:
            self.writeVar(f, tab, p)
        # write variables (outputs)
        for p in self.outports:
            self.writeVar(f, tab, p)
        # write tail
        f.write(f"{tab}$upscope $end{EOL}")
        # done
        return

    def updateInputPorts(self):
        for p in self.inports: p.update()
        return

    def export(self):
        exportResult = ""
        for p in self.exports:
            exportResult += p.export()
        return exportResult

    def display(self):
        pass

# RANDOM BITS GENERATOR ##############################################

# import random generator for initialising registers bits
from numpy.random import randint

def randbit(size = 1):
    n, s = 0, ""
    while n < size:
        s += f'{randint(256):0{8}b}'
        n += 8
    return s[0:size]

# EXAMPLE ############################################################

if __name__ == "__main__":

    from sys import version as pythonVersion

    print("file: core.py")
    print("content: system simulator core")
    print("created: 2020 November 14 Saturday")
    print("author: roch schanen")
    print("comment: core classes")
    print("run Python3:" + pythonVersion)

    # instantiate simulator
    S = system("version 0.00")    

    # show all devices defined
    S.displayDevices()

    # open export file
    S.openFile()    
    # run simulator    
    S.runUntil(500)
    # close export file
    S.closeFile()
