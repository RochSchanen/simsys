#!/usr/bin/python3
# file: simsys.py
# content: system simulator
# created: 2020 july 19 Sunday
# modified:
# modification:
# author: roch schanen
# comment: system architecture simulator

# todo: make signals
# todo: make bus
# todo: make engine
# todo: make processor
# todo: make memory
# todo: make devices
# todo: make time, records, etc... 
# todo: break point, step-by-step, state display

# collect every device in the system
# run system engine and record data

from numpy.random import randint as rnd
from time import strftime 
from sys import exit

# SYSTEM / MODULE #########################################

class system():

    def __init__(self, name):
        date = strftime("%A, %d %b %Y at %H:%M:%S")
        print(f"create system {name}\n{date}")
        self.devicelist = {}
        self.name = name
        self.date = date
        self.time = 0
        # done
        return

    # time units are in ns (float) 
    def addClock( 
        self,
        period = 20,    # 20ns, 50MHz
        width  = 10,    # symetrical clock
        phase  = 0,     # 0ns, in phase
        name   = None): # None, generic name

        # get generic clock name
        if not name:
            # find a new name
            n, k = 0, "clk0"
            while k in self.devicelist.keys():
                n += 1
                k = f"clk{n}"
            # found name
            name = k

        # create
        self.devicelist[name] = \
            clock(period, width, phase, name)

        # done
        return self.devicelist[name]

    # time units are in ns (float) 
    def addCounter( 
        self,
        size = 4,     # 4, half a byte
        name = None): # None, generic name

        # get generic counter name
        if not name:
            # find a new name
            n, k = 0, "cnt0"
            while k in self.devicelist.keys():
                n += 1
                k = f"cnt{n}"
            # found name
            name = k

        # create
        self.devicelist[name] = \
            counter(size, name)

        # done
        return self.devicelist[name]

    #                                                 !!!!!
    def displayDevices(self):
        for d in self.devicelist.values(): d.display()            
        return

    def openFile(self, pathName = "./output.vcd"):
        # create file
        fh = open(pathName, 'w')
        # make header
        fh.write(f"$version Generated by simsys.py $end\n")
        fh.write(f"$date {self.date} $end\n")
        # fh.write(f"$timezero 0 $end\n")
        fh.write(f"$timescale 1ns $end\n")
        # make modules and signals
        n = 0
        fh.write(f"$scope module SYSTEM $end\n")
        for d in self.devicelist.values():
            n = d.makeModule(fh, n, 0)
        fh.write(f"$upscope $end\n")
        # close header
        fh.write(f"$enddefinitions $end\n")

        # set initial values at time zero             !!!!!
        fh.write(f"#0\n")
        for d in self.devicelist.values():
            fh.write(d.export())

        # done
        self.pathName = pathName
        self.fh = fh
        return

    def closeFile(self):
        self.fh.close()
        return

    def runStep(self):
        # export new state
        exportResult = ""
        for device in self.devicelist.values():
            exportResult += device.export()
        # export
        if exportResult:
            self.fh.write(f"#{self.time}\n")
            self.fh.write(exportResult)
        # increase time by step interval [ns]
        self.time += 1
        # update device outputs
        for device in self.devicelist.values():
            device.updateOutputPorts(self.time)
        # update device inputs
        for device in self.devicelist.values():
            device.updateInputPorts()        
        # done
        return

    def runUntil(self, time):
        while self.time < time:
            self.runStep()
        return

# OUTPUT PORTS ############################################

class outPort():

    def __init__(self, bits = 1):
        # so far, default is undefined value 'U'
        self.state = 'U'*bits
        # force update at origin
        self.uptodate = False
        # export signal
        self.signal = None
        return

    def addSignal(self, n):
        self.signal = f"W{n}"
        return self.signal

    def get(self):
        return self.state

    def size(self):
        return len(self.state)

    def set(self, newvalue):
        # check type is string 
        if not isinstance(newvalue, str):
            print(f"port.set: value must be of string type.")
            print(f"  exiting...")
            exit()
        # check size
        if not len(newvalue) == self.size():
            print(f"port.set: value size mismatch:")
            print(f"  value size is {len(value)}.")
            print(f"  expected size is {self.size()}.")
            print(f"  exiting...")
            exit()
        # set flag
        self.uptodate = (self.state == newvalue)
        # update value
        self.state = newvalue
        # done
        return

    # export to VCD format
    def export(self):
        if self.signal:
            # no change
            if self.uptodate: return ""
            # set flag
            self.uptodate = True
            # bit string export
            if self.size() > 1:
                return f"b{self.state} {self.signal}\n"
            # single bit export
            return f"{self.state}{self.signal}\n"
        # no signal
        return ""

# INPUT PORTS #############################################

class inPort():

    def __init__(self, port):
        # linking (network)
        self.p = port # reference to class object
        # initial state
        self.state = port.get()
        # force update at origin
        self.uptodate = False
        # export signal
        self.signal = None
        # edge events        
        self.rising  = False
        self.falling = False
        return

    def addSignal(self, n):
        self.signal = f"W{n}"
        return self.signal

    def get(self):
        return self.state

    def size(self):
        return len(self.state)

    def update(self):
        newvalue = self.p.get()
        # update flag
        self.uptodate = (self.state == newvalue)
        # update value
        if self.p.size() > 1:
            self.state = newvalue
            return
        # single bit case        
        self.rising  = False
        self.falling = False
        # detect rising edge
        if (self.state, newvalue) == ('0','1'):
            self.rising = True                 
        # detect falling edge
        if (self.state, newvalue) == ('1','0'):
            self.falling = True
        # update state
        self.state = newvalue                 
        return

    # export to VCD format
    def export(self):
        if self.signal:
            # no change
            if self.uptodate: return ""
            # set flag
            self.uptodate = True
            # bit string export
            if self.size() > 1:
                return f"b{self.state} {self.signal}\n"
            # single bit export
            return f"{self.state}{self.signal}\n"
        # no signal
        return ""

# COUNTER #################################################

# todo: counter options
# clr on active low, high
# trg on rising, falling edge
# wrt on active low, high
# ena on active low, high
# cse on active low, high
# initial value random, zero, maybe undefined
# maybe parallel, serial load

class counter():

    # activated when input connected
    clr = None # clear   (reset)
    trg = None # trigger (clock)
    wrt = None # write   (load)
    ena = None # enable  (output)
    cse = None # chip select

    def __init__(
        self,
        size,   # counter bits width 
        name):  # counter name
        # record data
        self.name = name
        self.configuration = size
        # instanciate output port
        self.Q = outPort(size)
        # setup output port with a random value
        self.Q.set(f'{rnd(size):0{size}b}')
        return

    def makeModule(self, fh, n, t):
        # get data
        name = self.name
        size = self.configuration
        # make tab for alignment
        tab  = '\t'*(t+1)
        # write module
        fh.write(f"{tab}$scope module {name} $end\n")

        # trg input
        if self.trg:
            l = f"{name}_trg"
            i = self.trg.addSignal(n)
            fh.write(f"{tab}\t$var wire 1 {i} {l} $end\n")
            n += 1

        # clr input
        if self.clr:
            l = f"{name}_clr"
            i = self.clr.addSignal(n)
            fh.write(f"{tab}\t$var wire 1 {i} {l} $end\n")
            n += 1

        # Q outputs
        l  = f"{name}_Q[{size-1}:0]"
        i = self.Q.addSignal(n)
        fh.write(f"{tab}\t$var wire {size} {i} {l} $end\n")
        n += 1

        # done
        fh.write(f"{tab}$upscope $end\n")
        return n

    def display(self):
        # get data
        name = self.name
        size = self.configuration
        value = self.Q.get()
        # display
        print(f"CNT: {name},{size},{value}")
        return

    def addTrigger(self, port):
        self.trg = inPort(port)
        return

    def addClear(self, port):
        self.clr = inPort(port)
        return

    def updateInputPorts(self):
        for port in [
            self.clr,   # clear port 
            self.trg]:  # trigger port
            if port:    # check instance
                port.update()
        return

    def updateOutputPorts(self, timeStamp):

        # get configuration
        size = self.configuration

        # asynchronous clear on active low
        if self.clr.state == '0':
            # clear ouputs
            self.Q.set(f'{0:0{size}b}')
            return

        # update on rising edge of trigger
        if self.trg.rising:
            # get incremented state
            n = int(self.Q.get(), 2) + 1
            # make n string, LSB(size) only
            newvalue = f'{n:0{size}b}'[-size:]
            # update outputs
            self.Q.set(newvalue)
            return

        # done
        return

    def export(self):
        exportResult = ""
        for port in [
            self.Q,     # output port
            self.clr,   # clear port
            self.trg]:  # trigger port
            exportResult += port.export()
        return exportResult

# CLOCK ###################################################

class clock():

    def __init__(
        self,
        period, # clock period (float time)
        width,  # pulse width  (float time)
        phase,  # phase shift  (float time)
        name):  # clock name
        # record data
        self.name = name
        self.configuration = period, width, phase
        # instanciate output port
        self.Q = outPort(1)
        # setup output port high
        self.Q.set('1')
        # done
        return

    def makeModule(self, fh, n, t):
        # get data
        name = self.name
        # make tab for alignment
        tab  = '\t'*(t+1)
        # make signal label
        label = f"{name}_Q"
        # register port for export (VCD)
        signal = self.Q.addSignal(n)
        # write module content
        fh.write(f"{tab}$scope module {name} $end\n")
        fh.write(f"{tab}\t$var wire 1 {signal} {label} $end\n")
        fh.write(f"{tab}$upscope $end\n")
        return n+1

    def display(self):
        # get data
        name = self.name
        period, width, phase = self.configuration
        value = self.Q.get()
        # display
        print(f"CLK: {name},{period},{width},{phase},{value}")
        return

    # no inputs
    def updateInputPorts(self):
        pass

    def updateOutputPorts(self, timeStamp):
        # get configuration
        period, width, phase = self.configuration
        # get new state
        m = (timeStamp-phase) % period
        newvalue = ['0','1'][m < width]
        # update output
        self.Q.set(newvalue)        
        return

    def export(self):
        exportResult = self.Q.export()
        return exportResult

# BUILD ###################################################

if __name__ == "__main__":

    import sys

    print("file: simsys.py")
    print("content: system simulator")
    print("created: 2020 july 19 Sunday")
    print("author: roch schanen")
    print("comment: system architecture simulator")
    print("run Python3:" + sys.version);

    # instanciate simulator
    mySystem = system("version 0.00")
    # instanciate a port of size 1:
    # add a button key to show on the waves 
    myResetButton = outPort(1)
    # instanciate a clock
    myclock = mySystem.addClock()
    # instanciate a counter
    myCounter = mySystem.addCounter()
    # make counter inputs network
    myCounter.addTrigger(myclock.Q)
    myCounter.addClear(myResetButton)
    # show all devices
    mySystem.displayDevices()
    # open export file
    mySystem.openFile()
    # run simulator    
    myResetButton.set('0')
    mySystem.runUntil(15)
    myResetButton.set('1')
    mySystem.runUntil(250)
    # close export file
    mySystem.closeFile()
