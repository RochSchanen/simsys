#!/usr/bin/python3
# file: simsys.py
# content: system simulator
# created: 2020 july 19 Sunday
# modified:
# modification:
# author: roch schanen
# comment: system architecture simulator

# todo: make signals
# todo: make bus
# todo: make engine
# todo: make processor
# todo: make memory
# todo: make devices
# todo: make time, records, etc... 
# todo: break point, step-by-step, state display

# todo: add validity check of device setup  

# collect every device in the system
# run system engine and record data

from numpy.random import randint as rnd
from numpy import log as ln
from time import strftime 
from sys import exit

# FOR COMPATIBILLTY ISSUES

SEP = " "    # SIGNAL SEPARATOR
EOL = "\n"   # END-OF-LINE CODE

# SIGNAL COUNTER
# the signal counter is used for the VCD file wire names.
# they are all given the format 'Wn' where 'W' is the letter W
# and 'n' is an index number. The value of n is given by the
# counter 'N'.

N = 0

# SYSTEM / MODULE #########################################

class system():

    # (generic)
    def __init__(self, name):
        date = strftime("%A, %d %b %Y at %H:%M:%S")
        print(f"create system {name}\n{date}")
        self.devicelist = {}
        self.name = name
        self.date = date
        self.time = 0
        # done
        return

    # (generic)
    # getName returns a name in the form 'Sn' where the string S
    # is a given generic name and 'n' is an index number. The index  
    # is incremented with every new call.
    def getName(self, generic):
        n, k = 0, f"{generic}0"
        while k in self.devicelist.keys():
            n += 1
            k = f"{generic}{n}"
        # found name
        return k

    # (generic)
    def displayDevices(self):
        for d in self.devicelist.values(): d.display()            
        return

    # (generic)
    # create a new VCD file and make the file header. 
    def openFile(self, pathName = "./output.vcd"):
        # create file
        fh = open(pathName, 'w')
        # make header
        fh.write(f"$version Generated by simsys.py $end{EOL}")
        fh.write(f"$date {self.date} $end{EOL}")
        fh.write(f"$timescale 1ns $end{EOL}")
        # make modules and signals
        fh.write(f"$scope module SYSTEM $end{EOL}")
        for d in self.devicelist.values(): d.makeModule(fh, 0)
        fh.write(f"$upscope $end{EOL}")
        # close header
        fh.write(f"$enddefinitions $end{EOL}")
        # done
        self.pathName = pathName
        self.fh = fh
        return

    # (generic)
    def closeFile(self):
        self.fh.close()
        return

    # (generic)
    # generate a new step in the simulation
    # the step resolution is so far set to 1ns
    def runStep(self):
        # export new state
        exportResult = ""
        for device in self.devicelist.values():
            exportResult += device.export()
        # export
        if exportResult:
            self.fh.write(f"#{self.time}")
            self.fh.write(f"{SEP}{exportResult}{EOL}")
        # increase time by one interval (1ns)
        self.time += 1
        # update device outputs
        for device in self.devicelist.values():
            device.updateOutputPorts(self.time)
        # update device inputs
        for device in self.devicelist.values():
            device.updateInputPorts()        
        # done
        return

    # (generic)
    # repeat steps until end time is reached
    def runUntil(self, time):
        while self.time < time:
            self.runStep()
        return

    # (specific)
    # create a clock.
    # period is the period (1/frequency) in ns.
    # width is the pulse length of the clock signal in ns.
    # phase is the delay of the clock pulse in ns.
    # a zero phase means that the rising edge of the
    # clock pulse starts at the beginning of the period.
    # the width plus th phase should not exceed the period.
    def createClock( 
        self,
        period = 20,    # 20ns, 50MHz
        width  = 10,    # symmetrical clock
        phase  = 0,     # 0ns, in phase
        name   = None): # None, generic name
        # check duplicate
        if name in self.devicelist.keys():
            print(f"system.createClock: clock name duplicated.")
            print(f"  name {name} already used.")
            print(f"  exiting...")
            exit()
        # get generic clock name
        if not name: name = self.getName("clk")
        # create
        self.devicelist[name] = \
            clock(period, width, phase, name)
        # done
        return self.devicelist[name]

    # (specific)
    # size is the number of bits.
    # n bits means counting between 0 and 2^n-1.
    # default is 4 bits which gives a count between 0 and 15.
    def createCounter( 
        self,
        size = 4,     # 4bits, count 0 to 15
        name = None): # None, generic name
        # check duplicate
        if name in self.devicelist.keys():
            print(f"system.createCounter: counter name duplicated.")
            print(f"  name {name} already used.")
            print(f"  exiting...")
            exit()
        # get generic counter name
        if not name: name = self.getName("cnt")
        # create
        self.devicelist[name] = \
            counter(size, name)
        # done
        return self.devicelist[name]

    # (specific)
    # create a reset signal.
    # length is the period of the reset signal in ns.
    # the reset signal occurs once at the start of the run.
    def createReset( 
        self,
        length = 1,   # 1, one cycle
        name = None): # None, generic name
        # check duplicate
        if name in self.devicelist.keys():
            print(f"system.createReset: reset name duplicated.")
            print(f"  name {name} already used.")
            print(f"  exiting...")
            exit()
        # get generic counter name
        if not name: name = self.getName("rst")
        # create
        self.devicelist[name] = \
            reset(length, name)
        # done
        return self.devicelist[name]

    # (specific)
    # size is the number of bits.
    # n bits means counting between 0 and 2^n-1.
    # default is 4 bits which gives a count between 0 and 15.
    def createLUT( 
        self,
        table = '1110', # default table is a 2 inputs NAND gate
        name = None): # None, generic name
        # check duplicate
        if name in self.devicelist.keys():
            print(f"system.createLUT: LUT name duplicated.")
            print(f"  name {name} already used.")
            print(f"  exiting...")
            exit()
        # get generic counter name
        if not name: name = self.getName("lut")
        # create
        self.devicelist[name] = \
            lut(table, name)
        # done
        return self.devicelist[name]

# PORT COMMON #############################################
# 'addSignal' add a signal name to the port and increment the
# signal count. 'export' returns the port state only if the
# state value has been changed. 

class portCommon():

    def addSignal(self):
        global N
        self.signal = f"W{N}"
        N += 1
        return self.signal

    def get(self):
        return self.state

    def size(self):
        return len(self.state)

    # export to VCD format
    def export(self):
        if self.signal:
            # no change
            if self.uptodate: return ""
            # set flag
            self.uptodate = True
            # bit string export
            if self.size() > 1:
                return f"b{self.state} {self.signal}{SEP}"
            # single bit export
            return f"{self.state}{self.signal}{SEP}"
        # no signal
        return ""

# OUTPUT PORTS ############################################
# 'set' asserts the value of the port. The method detects if
# the asserted value has changed the value of the port and sets
# the 'uptodate' flag. no change <=> 'uptodate' is true.

class outPort(portCommon):

    def __init__(self, bits = 1, name = None):
        # initialise to undefined value 'U'
        self.state = 'U'*bits
        # register port name
        self.name = name
        # force update at origin
        self.uptodate = False
        # export signal
        self.signal = None
        return

    def set(self, newvalue):
        # check type is string 
        if not isinstance(newvalue, str):
            print(f"port.set: value must be of string type.")
            print(f"  exiting...")
            exit()
        # check size
        if not len(newvalue) == self.size():
            print(f"port.set: value size mismatch:")
            print(f"  value size is {len(value)}.")
            print(f"  expected size is {self.size()}.")
            print(f"  exiting...")
            exit()
        # set flag
        self.uptodate = (self.state == newvalue)
        # update value
        self.state = newvalue
        # done
        return

# INPUT PORTS #############################################

class inPort(portCommon):
# an input port is always linked to an output port.
# !!! create two port constant: vcc and gnd.
# 'update' sets the new value of the input port from
# its linked output port value. It sets the 'uptodate' flag.
# it also detects the 'rising' and 'falling' edge events.

    def __init__(self, port, name = None):
        # linking (adding to the network)
        self.p = port
        # register port name
        self.name = name
        # initial state
        self.state = port.get()
        # force update at origin
        self.uptodate = False
        # export signal
        self.signal = None
        # clear edge events        
        self.rising  = False
        self.falling = False
        return

    def update(self):
        newvalue = self.p.get()
        # update flag
        self.uptodate = (self.state == newvalue)
        # update value
        if self.p.size() > 1:
            self.state = newvalue
            return
        # single bit case        
        self.rising  = False
        self.falling = False
        # detect rising edge
        if (self.state, newvalue) == ('0','1'):
            self.rising = True                 
        # detect falling edge
        if (self.state, newvalue) == ('1','0'):
            self.falling = True
        # update state
        self.state = newvalue                 
        return

# DEVICE #################################################
# the 'Device' class is a template class.
# 'writeVar' helps to format the header of the VCD file.
# 'makeModule' write this device header for the VCD file. 

class Device():

    def __init__(self,
            name):  # device name
        self.name = name
        self.inports  = []
        self.outports = []
        self.exports  = []
        return

    def writeVar(self,
            f,  # file
            t,  # tab level
            p): # port
        # write port signal
        if p.name:
            # register port in export list
            self.exports.append(p)
            # get size
            size = p.size()
            # get signal name
            label = f"{self.name}_{p.name}"
            if size > 1:
                label += f"[{size-1}:0]"
            # get signal identifier
            signal = p.addSignal()
            f.write(f"{t}\t$var")    # header
            f.write(f" wire {size}") # signal size
            f.write(f" {signal}")    # signal identifier
            f.write(f" {label}")     # signal name
            f.write(f" $end{EOL}")   # tail
        return

    def makeModule(self,
            f,  # file
            t): # tab level
        # get module name
        name = self.name
        # tab alignment
        tab  = '\t'*(t+1)
        # write header
        f.write(f"{tab}$scope module {name} $end{EOL}")
        # write variables (inputs)
        for p in self.inports:
            self.writeVar(f, tab, p)
        # write variables (outputs)
        for p in self.outports:
            self.writeVar(f, tab, p)
        # write tail
        f.write(f"{tab}$upscope $end{EOL}")
        # done
        return

    def updateInputPorts(self):
        for p in self.inports: p.update()
        return

    def export(self):
        exportResult = ""
        for p in self.exports:
            exportResult += p.export()
        return exportResult

    def display(self):
        pass

# the following classes are built on the 'Device' template class.

# COUNTER #################################################

# todo: counter options
# clr on active low, high
# trg on rising, falling edge
# wrt on active low, high
# ena on active low, high
# cse on active low, high
# initial value random, zero, maybe undefined
# maybe parallel, serial load

class counter(Device):

    # the following ports are activated only when
    # an input port is dynamically connected to them  
    clr = None # clear   (reset)
    trg = None # trigger (clock)
    # wrt = None # write   (load) ...to implement
    # ena = None # enable  (output) ...to implement
    # cse = None # chip select ...to implement

    # re-define __init__ to add parameter 'size'
    def __init__(self,
            size,   # counter bits width 
            name):  # counter name
        # call parent class constructor
        Device.__init__(self, name)
        # record configuration
        self.configuration = size
        # instantiate output port
        self.Q = outPort(size, "Q")
        # register port
        self.outports.append(self.Q)
        # set initial output port value
        # self.Q.set('X'*size)               # undefined values
        self.Q.set(f'{rnd(size):0{size}b}')  # random values
        return

    def addTrigger(self,
            p): # port
        # instantiate input port
        self.trg = inPort(p, "trg")
        # register port
        self.inports.append(self.trg)
        return

    def addClear(self,
            p): # port
        # instantiate input port
        self.clr = inPort(p, "clr")
        # register port
        self.inports.append(self.clr)
        return

    def display(self):
        name = self.name
        size = self.configuration
        value = self.Q.get()
        # display
        print(f"CNT: {name},{size},{value}")
        return

    # here is defined the behaviour of the counter device
    # asynchronous reset (counter is zero whenever 'clr' is low)
    # synchronous increment on the rising edge of 'clk'
    # the counter value is coerced modulo 'size'.
    def updateOutputPorts(self, timeStamp):
        # get configuration
        size = self.configuration
        # asynchronous clear on active low
        if self.clr.state == '0':
            # clear output
            self.Q.set(f'{0:0{size}b}')
            return
        # update on rising edge of trigger
        if self.trg.rising:
            # get incremented state
            n = int(self.Q.get(), 2) + 1
            # make n string, LSB(size) only
            newvalue = f'{n:0{size}b}'[-size:]
            # new output
            self.Q.set(newvalue)
            return
        # done
        return

# CLOCK ###################################################

class clock(Device):

    # re-define __init__ to add parameters:
    # 'period', 'width' and 'phase'.
    def __init__(
            self,
            period, # clock period (float time)
            width,  # pulse width  (float time)
            phase,  # phase shift  (float time)
            name):  # clock name
        # call parent class constructor
        Device.__init__(self, name)
        # record configuration
        self.configuration = period, width, phase
        # instantiate output ports
        self.P = outPort(1, "P")
        self.Q = outPort(1, "Q")
        # register port
        self.outports.append(self.P)
        self.outports.append(self.Q)
        # set default output ports value
        self.P.set('1')
        self.Q.set('0')
        # done
        return

    def display(self):
        name = self.name
        period, width, phase = self.configuration
        value = f"{self.P.get()},{self.Q.get()}"
        # display
        print(f"CLK: {name},{period},{width},{phase},{value}")
        return

    # here is defined the behaviour of the clock device
    # the device has also an inverted output. 
    def updateOutputPorts(self, timeStamp):
        # get configuration
        period, width, phase = self.configuration
        # get new state
        m = (timeStamp-phase) % period
        # update ouputs
        self.P.set(['0','1'][m < width])
        self.Q.set(['1','0'][m < width])
        # done
        return

# RESET ###################################################

class reset(Device):

    def __init__(self,
            length, # clear delay length
            name):  # device name
        # call parent class constructor
        Device.__init__(self, name)
        # record configuration
        self.configuration = length
        # instantiate output port
        self.Q = outPort(1, "Q")
        # register port
        self.outports.append(self.Q)
        # set default output ports value
        self.Q.set('0')
        # done
        return

    def display(self):
        name = self.name
        length = self.configuration
        value = f"{self.Q.get()}"
        # display
        print(f"RST: {name},{length},{value}")
        return

    def updateOutputPorts(self, timeStamp):
        # get configuration
        length = self.configuration
        # compute output
        value = ['1','0'][timeStamp < length]
        # update output
        self.Q.set(value)
        # done
        return

# LUT #################################################
# look up table logic: logic element of FPGAs and other
# types of programmable logic. inputs are ordered with
# the least significant bit being the first added. 

class lut(Device):

    # re-define __init__ to add parameter 'size'
    def __init__(self,
            table,  # lut table
            name):  # counter name
        # call parent class constructor
        Device.__init__(self, name)
        # compute size
        size = int(ln(len(table))/ln(2))
        # record configuration
        self.configuration = size, table
        # instantiate output port
        self.Q = outPort(1, "Q")
        # register port
        self.outports.append(self.Q)
        # set default output port value (random bits)
        self.Q.set('X')
        return

    def addInput(self,
            p): # port
        # instantiate input port
        newport = inPort(p, f"I{len(self.inports)}")
        # register new port
        self.inports.append(newport)
        return

    def display(self):
        name = self.name
        size, table = self.configuration
        value = self.Q.get()
        # display
        print(f"LUT: {name},{size},{table},{value}")
        if not size == len(self.inports):
            print(f"  Size mismatch.")
            print(f"    {size} input(s) expected.")
            print(f"    {len(self.inports)} input(s) found.")
            print(f"  Exiting...")
            exit()
        return

    # the LUT device returns the table value pointed
    # by the input address value. 
    def updateOutputPorts(self, timeStamp):
        # get configuration
        size, table = self.configuration
        # get table address
        a, w = 0, 1 << (size-1)
        for i in self.inports:
            a += w*['0','1'].index(i.get())
            w >>= 1
        # set new value
        self.Q.set(table[a])
        # done
        return


# EXAMPLE #################################################

if __name__ == "__main__":

    import sys

    print("file: simsys.py")
    print("content: system simulator")
    print("created: 2020 july 19 Sunday")
    print("author: roch schanen")
    print("comment: system architecture simulator")
    print("run Python3:" + sys.version);

    # instantiate simulator
    S = system("version 0.00")
    
    # add reset signal
    rst = S.createReset(35) # hold reset for 35ns

    # instantiate clock
    clk0 = S.createClock(10,5)
    clk1 = S.createClock(20,10)

    # instantiate counter and make network
    cnt = S.createCounter()
    cnt.addTrigger(clk1.Q) # use clock output 'Q' for counter trigger
    cnt.addClear(rst.Q) # use reset output 'Q' for counter reset

    # instantiate LUT
    lut1 = S.createLUT('1001')
    lut1.addInput(clk0.Q)
    lut1.addInput(clk1.Q)

    # show all devices defined
    S.displayDevices()

    # open export file
    S.openFile()    
    # run simulator    
    S.runUntil(500)
    # close export file
    S.closeFile()
